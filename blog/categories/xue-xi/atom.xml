<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 学习 | kAir]]></title>
  <link href="http://kAirzhen.github.io/blog/categories/xue-xi/atom.xml" rel="self"/>
  <link href="http://kAirzhen.github.io/"/>
  <updated>2014-08-06T20:21:59+08:00</updated>
  <id>http://kAirzhen.github.io/</id>
  <author>
    <name><![CDATA[贞]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何在App中发送邮件]]></title>
    <link href="http://kAirzhen.github.io/blog/2014/08/06/%E5%A6%82%E4%BD%95%E5%9C%A8App%E4%B8%AD%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    <updated>2014-08-06T20:04:00+08:00</updated>
    <id>http://kAirzhen.github.io/blog/2014/08/06/如何在App中发送邮件</id>
    <content type="html"><![CDATA[<p>目标：App 实现的功能是 – 当用户轻拍 Contact Us 按钮时,将弹出 email 界面。</p>

<p>首先，interface builder 界面,连接按钮和 action 方法。命名方法名称 – showEmail, 保留 Event 事件为 Touch Up Inside。
然后，实现 Email 接口，接着,引入 MessageUI.h 头文件,实现在 SimpleEmailViewController.h 中 MFMailComposeViewControllerDelegate 委托。
代码实现：</p>

<h1>import &lt;UIKit/UIKit.h>#import &lt;MessageUI/MessageUI.h>@interface SimpleEmailViewController : UIViewController <MFMailComposeViewControllerDelegate> // Add the delegate &ndash; (IBAction)showEmail:(id)sender;@end选择 SimpleEmailViewController.m 文件,实现 showEmail 方法和MFMailComposeViewControllerDelegate 委托。在实现文件中添加如下代码:￼- (IBAction)showEmail:(id)sender { // Email SubjectNSString <em>emailTitle = @&ldquo;Test Email&rdquo;;NSString </em>messageBody = @&ldquo;This programming is so fun!&rdquo;;NSArray <em>toRecipents = [NSArray arrayWithObject:@&ldquo;<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x73;&#117;&#112;&#112;&#111;&#x72;&#x74;&#x40;&#x61;&#x70;&#112;&#99;&#111;&#100;&#97;&#46;&#99;&#111;&#x6d;">&#115;&#x75;&#x70;&#x70;&#x6f;&#114;&#116;&#64;&#x61;&#112;&#112;&#99;&#x6f;&#100;&#x61;&#46;&#x63;&#111;&#x6d;</a>&rdquo;];MFMailComposeViewController </em>mc = [[MFMailComposeViewController alloc] init];mc.mailComposeDelegate = self;[mc setSubject:emailTitle];[mc setMessageBody:messageBody isHTML:NO]; [mc setToRecipients:toRecipents];[self presentViewController:mc animated:YES completion:NULL];}//在屏幕上显示 email 界面- (void) mailComposeController:(MFMailComposeViewController <em>)controller￼didFinishWithResult:(MFMailComposeResult)result error:(NSError </em>)error {switch (result) {case MFMailComposeResultCancelled: NSLog(@&ldquo;Mail cancelled&rdquo;);break;case MFMailComposeResultSaved: NSLog(@&ldquo;Mail saved&rdquo;);break;case MFMailComposeResultSent: NSLog(@&ldquo;Mail sent&rdquo;);break;case MFMailComposeResultFailed:NSLog(@&ldquo;Mail sent failure: %@&rdquo;, [error localizedDescription]); break;default: break;}[self dismissViewControllerAnimated:YES completion:NULL];}代码定义了邮件的主题,邮件内容和接收人，创建了内置的 MFMailComposeViewController 对象，MFMailComposeViewController 类提供了标准接口管理编辑和发送 email 消息。可以使用这个视图控制器在App 中显示一个标准的 email 视图。使用初始值,包括接收人邮件地 址,主题和邮件内容等等填充该视图的相关字段。</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[往本地文件系统写入用户注册信息的两种方法]]></title>
    <link href="http://kAirzhen.github.io/blog/2014/07/28/%E5%BE%80%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%86%99%E5%85%A5%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <updated>2014-07-28T22:13:00+08:00</updated>
    <id>http://kAirzhen.github.io/blog/2014/07/28/往本地文件系统写入用户注册信息的两种方法</id>
    <content type="html"><![CDATA[<p>&ndash;(IBAction)userRegister:(id)sender{</p>

<p>NSString*userRecord = [NSString stringWithFormat:@“\n%@,%@,%@&ldquo;,</p>

<pre><code>               self.userName.text,

               self.password.text,

               self.email.text];
</code></pre>

<p>NSString *docDir = [NSSearchPathForDirectoriesInDomains,</p>

<pre><code>                            NSDocumentDirectory,

                            NSUserDomainMask,YES)objectAtIndex: 0
</code></pre>

<p>];</p>

<p>NSString *userFile = [docDir stringByAppendingPathComponent:@&ldquo;userDat a.csv”];
NSLog(@“%@“,userFile);</p>

<p>if(![[NSFileManager defaultManager]fileExistsAtPath:userFile]){</p>

<p>if([[NSFileManager defaultManager]createFileAtPath:userFile contents:ni l attributes:nil)</p>

<p>NSLog(@“YES”);
else{</p>

<p>NSLog(@&ldquo;NO&mdash;注册失败!”);</p>

<pre><code>             }
      }
</code></pre>

<p>NSFileHandle *fileHandle = [NSFileHandle fileHandleForUpdatingAtPath:us erFile];</p>

<p>[fileHandle seekToEndOfFile];</p>

<p> [fileHandle writeData:[userRecord dataUsingEncoding:NSUTF8StringEncoding]];</p>

<p>[fileHandle closeFile];</p>

<p>[self regSuccess]</p>

<p>self.userName.text = @“";</p>

<p>self.password.text = @“";
self.email.text = @“";
}
另外,还有一个辅助的方法 regSuccess,用来在屏幕上弹出用户注册成功的提示信息:
&ndash;(void)regSuccess{
  UIAlertView <em>alertDialog;
  alertDialog = [[UIAlertView alloc]initWithTitle:@&ldquo;EntLib.com 电子图书管理系统&rdquo;       message:@&ldquo;注册成功!&rdquo;
  delegate:self
  cancelButtonTitle:@&ldquo;OK&rdquo;
  otherButtonTitles:nil];
  [alertDialog show];}
接下来,是一个 NSFileHandle 类的 fileHandleForUpdatingAtPath 方法,获取指定该文件的引用,更新该文件。跳到文件的末尾,调用 writeData 方法,将用户注册信息写入到文件中。NSFileHandle </em>fileHandle =[NSFileHandle fileHandleForUpdatingAtPath:us erFile];[fileHandle seekToEndOfFile];
[fileHandle writeData:[userRecord dataUsingEncoding:NSUTF8StringEncoding];[fileHandle closeFile];在文件写入完毕之后,调用 closeFile 方法关闭文件手柄。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello]]></title>
    <link href="http://kAirzhen.github.io/blog/2014/07/19/hello/"/>
    <updated>2014-07-19T16:05:00+08:00</updated>
    <id>http://kAirzhen.github.io/blog/2014/07/19/hello</id>
    <content type="html"><![CDATA[<p>hello！</p>
]]></content>
  </entry>
  
</feed>
